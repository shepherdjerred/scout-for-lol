---
globs: *.ts,*.tsx
---

# TypeScript Code Standards

## Strict Type Safety Rules

- **NEVER use `any`** - Always define proper types
- **Avoid type assertions (`as`)** - Use type guards instead
- **Use unknown for uncertain types** - Validate with Zod before processing
- **Prefer advanced types** - Mapped types, conditional types, template literals
- **Exhaustive pattern matching** - Use `ts-pattern` for complex branching

## Validation Patterns

```typescript
// Always validate unknown input with Zod
const result = SomeSchema.safeParse(unknownData);
if (!result.success) {
  throw new Error(fromZodError(result.error).toString());
}

// Use type guards instead of casting
function isString(value: unknown): value is string {
  return typeof value === 'string';
}
```

## Error Handling

- Use `zod-validation-error` for user-friendly error messages
- Handle errors at appropriate levels
- Use Result patterns where appropriate
- Proper async/await error handling

## Performance & Memory

- Lazy load heavy dependencies
- Clean up resources and connections
- Use proper caching strategies
- Consider memory implications of data structures

## Function Parameter Design

### Avoid Optional Parameters with Defaults

- **Make parameters required when they affect behavior** - Don't hide important decisions behind defaults
- **Use explicit values at call sites** - Makes intent clear and behavior obvious
- **Defaults mask bugs** - TypeScript won't catch missing parameters when defaults exist

**❌ BAD - Default masks intent:**

```typescript
function fetchData(
  id: string,
  purpose: "read" | "write" = "read"  // Default hides important decision
) {
  // Behavior differs significantly based on purpose
  if (purpose === "write") {
    // Different logic path
  }
}

// Call site unclear - what is the purpose?
fetchData(id);  // Is this reading or writing?
```

**✅ GOOD - Explicit parameter forces clarity:**

```typescript
function fetchData(
  id: string,
  purpose: "read" | "write"  // Required - no default
) {
  // Behavior differs significantly based on purpose
  if (purpose === "write") {
    // Different logic path
  }
}

// Call site is explicit and clear
fetchData(id, "read");   // Obviously reading
fetchData(id, "write");  // Obviously writing
```

**When defaults ARE acceptable:**

- UI/display options that don't affect core behavior
- Pagination/limits where default is sensible
- Feature flags that default to "off"

**When defaults are FORBIDDEN:**

- Parameters that change core behavior/logic paths
- Parameters that affect data integrity/validation
- Parameters that change what gets stored/fetched
- Parameters that affect security/permissions

## Dependencies

- Use `remeda` for functional data transformations
- Use `ts-pattern` for complex control flow
- Use `env-var` for type-safe environment configuration
- Use `date-fns` for date operations
