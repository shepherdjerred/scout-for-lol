---
description: TypeScript code standards and strict type safety rules
globs: "*.ts,*.tsx"
---

# TypeScript Code Standards

## Strict Type Safety Rules

- **NEVER use `any`** - Always define proper types
- **Avoid type assertions (`as`)** - Use type guards instead
- **Use unknown for uncertain types** - Validate with Zod before processing
- **Prefer `undefined` over `null`** - Use `undefined` for optional/missing values; only use `null` when required by external APIs or libraries
- **Prefer advanced types** - Mapped types, conditional types, template literals
- **Exhaustive pattern matching** - Use `ts-pattern` for complex branching

## Validation Patterns

```typescript
// Always validate unknown input with Zod
const result = SomeSchema.safeParse(unknownData);
if (!result.success) {
  throw new Error(fromZodError(result.error).toString());
}

// Use type guards instead of casting
function isString(value: unknown): value is string {
  return typeof value === 'string';
}
```

## Error Handling

- Use `zod-validation-error` for user-friendly error messages
- Handle errors at appropriate levels
- Use Result patterns where appropriate
- Proper async/await error handling

## Performance & Memory

- Lazy load heavy dependencies
- Clean up resources and connections
- Use proper caching strategies
- Consider memory implications of data structures

## Function Parameter Design

### Avoid Optional Parameters with Defaults

- **Make parameters required when they affect behavior** - Don't hide important decisions behind defaults
- **Use explicit values at call sites** - Makes intent clear and behavior obvious
- **Defaults mask bugs** - TypeScript won't catch missing parameters when defaults exist

**❌ BAD - Default masks intent:**

```typescript
function fetchData(
  id: string,
  purpose: "read" | "write" = "read"  // Default hides important decision
) {
  // Behavior differs significantly based on purpose
  if (purpose === "write") {
    // Different logic path
  }
}

// Call site unclear - what is the purpose?
fetchData(id);  // Is this reading or writing?
```

**✅ GOOD - Explicit parameter forces clarity:**

```typescript
function fetchData(
  id: string,
  purpose: "read" | "write"  // Required - no default
) {
  // Behavior differs significantly based on purpose
  if (purpose === "write") {
    // Different logic path
  }
}

// Call site is explicit and clear
fetchData(id, "read");   // Obviously reading
fetchData(id, "write");  // Obviously writing
```

**When defaults ARE acceptable:**

- UI/display options that don't affect core behavior
- Pagination/limits where default is sensible
- Feature flags that default to "off"

**When defaults are FORBIDDEN:**

- Parameters that change core behavior/logic paths
- Parameters that affect data integrity/validation
- Parameters that change what gets stored/fetched
- Parameters that affect security/permissions

## Dependencies

- Use `remeda` for functional data transformations
- Use `ts-pattern` for complex control flow
- Use `env-var` for type-safe environment configuration
- Use `date-fns` for date operations

## How TypeScript Checking Works in This Project

### Running Type Checks

```bash
# Run TypeScript compiler
bun run typecheck
mise run typecheck

# Type-aware ESLint (runs with TypeScript)
bun run lint
mise run lint
```

**What gets checked:**
- Type annotations on all variables and parameters
- Null/undefined safety (`strictNullChecks`)
- No implicit `any` types (`noImplicitAny`)
- All code paths return values (`noImplicitReturns`)
- Unused variables and parameters are flagged
- Imports/exports match across packages

### TypeScript Configuration

The project uses strict TypeScript settings configured in `tsconfig.base.json`:

| Option | Value | What It Enforces |
|--------|-------|------------------|
| `strict` | `true` | All strict checks enabled |
| `strictNullChecks` | `true` | Handle null/undefined explicitly |
| `noImplicitAny` | `true` | All types must be explicit |
| `noImplicitThis` | `true` | `this` must be typed |
| `noUnusedLocals` | `true` | No unused variables |
| `noUnusedParameters` | `true` | No unused parameters |
| `noImplicitReturns` | `true` | All code paths must return |
| `exactOptionalPropertyTypes` | `true` | Optional properties can't be `undefined` |

### Project References

The monorepo uses TypeScript project references for proper type checking across packages:

```
tsconfig.json (root)
├── packages/backend/tsconfig.json
├── packages/data/tsconfig.json
├── packages/report/tsconfig.json
├── packages/frontend/tsconfig.json
├── packages/report-ui/tsconfig.json
└── packages/review-dev-tool/tsconfig.json
```

**Impact:**
- Each package has its own type checking context
- Can't import from packages not in workspace
- Circular dependencies are caught immediately
- Incremental builds are faster

**Building:** When editing `tsconfig.json`, run:
```bash
bun run generate  # Regenerate TypeScript references
```

## Common TypeScript Errors and Fixes

### Error: "Type 'X' is not assignable to type 'Y'"

**Cause:** Type mismatch between variable and usage

```typescript
// ❌ WRONG
const count: number = "5";  // string assigned to number

// ✅ CORRECT
const count: number = 5;
// OR
const countStr = "5";
const count = Number(countStr);
```

### Error: "Object is possibly 'null' or 'undefined'"

**Cause:** Using value without null check

```typescript
// ❌ WRONG
const date = competition.startDate;
const isPast = date > now;  // date might be null!

// ✅ CORRECT
const date = competition.startDate;
if (date !== null) {
  const isPast = date > now;
}
// OR
const isPast = date && date > now;
```

### Error: "Property 'X' does not exist on type 'Y'"

**Cause:** Wrong field name or missing type

```typescript
// ❌ WRONG
const user = userData;
console.log(user.fullName);  // Property doesn't exist

// ✅ CORRECT - Define proper type
const UserSchema = z.object({ name: z.string() });
const user = UserSchema.parse(userData);
console.log(user.name);
```

### Error: "Variable has type 'any'"

**Cause:** Missing type annotation

```typescript
// ❌ WRONG
function process(data) {  // 'data' is implicitly any
  return data.field;
}

// ✅ CORRECT
function process(data: unknown): string {
  const schema = z.object({ field: z.string() });
  return schema.parse(data).field;
}
```

### Error: "'X' is declared but never used"

**Cause:** Unused variable or import

```typescript
// ❌ WRONG
import { User } from "./types";  // Imported but not used
import { userId } from "./config";  // Parameter not used

// ✅ CORRECT
import type { User } from "./types";  // Only used in types
// OR remove entirely if not needed
```

**For intentionally unused variables:**
```typescript
function handleError(_error: unknown) {  // Prefix with _ to ignore
  logToSentry(); // Just log, don't use error
}
```

## Type-Aware Linting

TypeScript ESLint rules require type information. They're slower but catch more bugs:

```bash
# These use type-aware linting
bun run lint

# Individual packages
cd packages/backend && bun run lint
```

**Type-aware rules enforce:**
- Unsafe operations on complex types
- Improper async/await usage
- Null-unsafe operations
- Redundant type checks

**If linting is slow:**
- Check your IDE's TypeScript version matches CLI
- Try: `rm -rf node_modules/.cache && bun install`
- See: `mise-and-dagger-usage.mdc` for performance tips

## Fixing TypeScript Before ESLint

**Important:** Fix TypeScript errors first, then ESLint errors

```bash
# ❌ WRONG (ESLint can't check uncompilable code)
mise check  # TypeScript fails, ESLint skipped

# ✅ CORRECT (Fix errors in order)
bun run typecheck          # Fix type errors first
bun run lint               # Then fix linting errors
bun run format:write       # Then format
```

The order matters because:
1. TypeScript errors prevent type-aware linting
2. ESLint can't analyze broken type context
3. Prettier formatting works on any valid code

## Satisfying TypeScript with Zod

Always use Zod to validate before using data:

```typescript
// ❌ WRONG - Trust the type, hope it's correct
const user: User = JSON.parse(response);
console.log(user.name);  // Could crash at runtime

// ✅ CORRECT - Validate and TypeScript infers type
const UserSchema = z.object({ name: z.string() });
const user = UserSchema.parse(JSON.parse(response));
console.log(user.name);  // Guaranteed to exist
```

## Related Topics

- **Type Assertions:** See `type-assertions-policy.mdc`
- **Type Safety Strategy:** See `type-safety-strategy.mdc`
- **Union Narrowing:** See `typescript-union-narrowing.mdc`
- **Common Pitfalls:** See `typescript-common-pitfalls.mdc`
- **ESLint Rules:** See `eslint-custom-rules.mdc`
- **Code Quality Checks:** See `code-quality-checklist.mdc`
- **Verification Systems:** See `mise-and-dagger-usage.mdc`
