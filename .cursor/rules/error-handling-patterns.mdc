---
description: Error handling patterns using Zod validation
---

# Error Handling Patterns

## Always Use Zod for Error Validation

**NEVER** use `instanceof Error` checks or custom type guards. Always use Zod schemas.

### ❌ WRONG

```typescript
catch (error) {
  if (error instanceof Error) {
    console.error(error.message);
  }
}

// Also wrong:
function isError(value: unknown): value is Error {
  return value instanceof Error;
}
```

### ✅ CORRECT

```typescript
import { z } from "zod";

const ErrorSchema = z.object({ message: z.string() });

catch (error) {
  const result = ErrorSchema.safeParse(error);
  if (result.success) {
    console.error(result.data.message);
  }
}
```

## Error Variables Should Be `unknown`

**NEVER** type error variables as `Error | null`. Always use `unknown`.

### ❌ WRONG

```typescript
let error: Error | null = null;
try {
  // ...
} catch (e) {
  error = e as Error;  // Type assertion!
}
```

### ✅ CORRECT

```typescript
let error: unknown = null;
try {
  // ...
} catch (e) {
  error = e;
}

const errorResult = ErrorSchema.safeParse(error);
if (errorResult.success) {
  expect(errorResult.data.message).toContain("expected text");
}
```

## Helper Pattern for Error Messages

For production code that needs error messages frequently:

```typescript
import { z } from "zod";

const ErrorSchema = z.object({ message: z.string() });

function getErrorMessage(error: unknown): string {
  const result = ErrorSchema.safeParse(error);
  return result.success ? result.data.message : String(error);
}

// Usage:
catch (error) {
  throw new Error(`Operation failed: ${getErrorMessage(error)}`);
}
```

## Why This Matters

1. **Linter Compliance**: Avoids `no-restricted-syntax` violations
2. **Type Safety**: `unknown` forces explicit validation before use
3. **Runtime Safety**: Zod validates the actual structure, not just the prototype chain
4. **Consistency**: Single pattern across the entire codebase
