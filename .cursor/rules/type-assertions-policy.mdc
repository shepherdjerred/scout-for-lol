---
description: When and how to use type assertions correctly
globs: "*.ts,*.tsx"
---

# Type Assertions Policy

## General Rule: Validate, Don't Assert

**ALWAYS prefer Zod validation over type assertions.**

## Acceptable Type Assertions

Type assertions are ONLY acceptable in these specific forms:

### 1. `as unknown as TargetType` (Two-Step Cast)

When interfacing with third-party libraries that don't have perfect types:

```typescript
// Validate with Zod first, then cast if necessary
const ResponseSchema = z.object({
  gameId: z.number(),
  gameMode: z.string(),
});

const validated = ResponseSchema.parse(response.response);
// Now we know the structure is correct
return response.response as unknown as ThirdPartyType;
```

### 2. `as const` (Literal Type)

For const assertions (always acceptable):

```typescript
const config = {
  type: "FIXED_DATES" as const,
  startDate: new Date(),
};
```

### 3. `as unknown` (Intermediate Cast)

When you need to pass validated data through a type boundary:

```typescript
const validated = Schema.parse(input);
return validated as unknown as ExpectedType;
```

## ❌ NEVER Use These

```typescript
// Direct cast (bypasses type safety):
error as Error

// Any cast:
value as any

// Unchecked cast:
data as SpecificType  // without Zod validation first
```

## The Zod-First Pattern

Always follow this sequence:

1. **Validate** with Zod schema
2. **Use** TypeScript's natural narrowing
3. **Assert** only when crossing library boundaries

```typescript
// 1. Validate
const DataSchema = z.object({
  id: z.number(),
  name: z.string()
});
const validated = DataSchema.parse(unknownData);

// 2. Use (TypeScript knows the type now)
console.log(validated.id, validated.name);

// 3. Assert (only if needed for third-party library)
return validated as unknown as ThirdPartyInterface;
```

## Why This Matters

1. **Runtime Safety**: Zod catches invalid data before it causes issues
2. **Compile Safety**: TypeScript catches type errors
3. **Linter Compliance**: Follows `no-restricted-syntax` rules
4. **Maintainability**: Clear validation logic, not hidden assumptions

## Import Types

Use `import type` for type-only imports:

```typescript
// ✅ CORRECT:
import { createCompetition, type CreateCompetitionInput } from "./queries.js";
import type { Competition } from "./types.js";

// ❌ WRONG:
import type { createCompetition } from "./queries.js";  // Function used at runtime!
```

## Template Literals

Never use values in template literals that could stringify poorly:

```typescript
// ❌ WRONG:
const msg = `Error: ${error}`;  // error is unknown

// ✅ CORRECT:
const ErrorSchema = z.object({ message: z.string() });
const result = ErrorSchema.safeParse(error);
const msg = result.success ? `Error: ${result.data.message}` : "Unknown error";
```

## Index Signatures

Use bracket notation for accessing index signature properties:

```typescript
// ❌ WRONG:
const value = obj.dynamicKey;  // If dynamicKey is from index signature

// ✅ CORRECT:
const value = obj["dynamicKey"];
```

## ESLint Enforcement: `no-type-assertions`

This policy is enforced by the custom ESLint rule `no-type-assertions`.

### What the Linter Checks

The rule disallows type assertions except:
1. `as unknown` - Widening type for later narrowing
2. `as const` - Const assertions for literal types

### Error Messages

```
error: Type assertions are not allowed except for casting to 'unknown' or 'as const'
```

### Examples Triggering the Linter

```typescript
// ❌ TRIGGERS LINTER - Direct type assertion
const user = userData as User;

// ❌ TRIGGERS LINTER - Multiple assertions
const value = (data as unknown) as SpecificType;

// ❌ TRIGGERS LINTER - Assert to any
const result = value as any;

// ❌ TRIGGERS LINTER - Assert Error type
const message = (error as Error).message;
```

### Examples That Don't Trigger

```typescript
// ✅ OK - as unknown
const unknownValue = someData as unknown;

// ✅ OK - as const
const config = { type: "production" } as const;

// ✅ OK - With Zod validation first
const UserSchema = z.object({ name: z.string() });
const validated = UserSchema.parse(userData);  // No cast needed
```

### Fixing Violations

**Option 1: Use Zod Validation (Preferred)**

```typescript
// ❌ LINTER ERROR
const user = userData as User;

// ✅ FIXED
const UserSchema = z.object({
  id: z.string(),
  name: z.string(),
});
const user = UserSchema.parse(userData);
```

**Option 2: Use Type Guards**

```typescript
// ❌ LINTER ERROR
function getName(value: unknown) {
  return (value as { name: string }).name;
}

// ✅ FIXED
function getName(value: unknown): string {
  if (typeof value === "object" && value !== null && "name" in value) {
    const typed = value as unknown as { name: unknown };
    if (typeof typed.name === "string") {
      return typed.name;
    }
  }
  throw new Error("Invalid value");
}

// OR with Zod
const NameSchema = z.object({ name: z.string() });
function getName(value: unknown): string {
  const result = NameSchema.safeParse(value);
  if (result.success) {
    return result.data.name;
  }
  throw new Error("Invalid value");
}
```

**Option 3: Use Optional Chaining**

```typescript
// ❌ LINTER ERROR
const name = (user as any).profile.name;

// ✅ FIXED
const name = user?.profile?.name ?? "Unknown";
```

### When Assertions Are Allowed

Two specific patterns are allowed:

#### 1. `as unknown` (Type Widening)

```typescript
// Allowed - widening to unknown
const unknown1 = someValue as unknown;

// Allowed - widening in two steps
const unknown2 = someValue as unknown as SpecificType;
```

#### 2. `as const` (Const Assertion)

```typescript
// Allowed - const assertion
const CONFIG = {
  type: "production" as const,
  version: 1 as const,
};

// Allowed - const on entire object
const obj = { a: 1, b: 2 } as const;
```

### Running the Linter

```bash
# Check for type assertion violations
bun run lint
mise run lint

# The rule is always enabled for .ts and .tsx files
# See eslint.config.ts for configuration
```

## Related Documentation

- **ESLint Rule Details:** See `eslint-custom-rules.mdc`
- **Type Safety Strategy:** See `type-safety-strategy.mdc`
- **Zod Validation:** See `zod-validation-patterns.mdc`
- **Code Quality Checks:** See `code-quality-checklist.mdc`
- **Common TypeScript Pitfalls:** See `typescript-common-pitfalls.mdc`
