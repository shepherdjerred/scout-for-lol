---
alwaysApply: true
---

# Type Safety Strategy

## The Core Principle: Validate at Boundaries

**External data enters your code at "boundaries". Validate there with Zod, then trust TypeScript everywhere else.**

### Boundaries Are

- API endpoints (request bodies, query params)
- Database queries (when structure is uncertain)
- User input (forms, commands)
- File I/O (JSON.parse, config files)
- Third-party libraries (untyped or poorly typed)
- Error objects in catch blocks

## The Type Safety Workflow

### 1. Define the Schema (Zod)

```typescript
const UserInputSchema = z.object({
  name: z.string().min(1).max(100),
  email: z.string().email(),
  age: z.number().int().positive(),
});
```

### 2. Extract the Type

```typescript
type UserInput = z.infer<typeof UserInputSchema>;
```

### 3. Validate at Boundary

```typescript
function handleUserInput(rawInput: unknown): UserInput {
  return UserInputSchema.parse(rawInput);
}
```

### 4. Use Safely Everywhere Else

```typescript
function processUser(user: UserInput): void {
  console.log(user.name);  // TypeScript knows this is safe
  saveToDatabase(user);    // All fields are validated
}
```

## When TypeScript Fights You, Step Back

If you're fighting TypeScript with multiple type assertions:

1. **Stop** - You're probably doing it wrong
2. **Validate** - Add Zod validation at the boundary
3. **Simplify** - Use simple if/else instead of complex abstractions
4. **Trust** - Let TypeScript's built-in narrowing work

### Example: Complex Union Issue

```typescript
// ❌ FIGHTING TypeScript:
const result = args as SomeType;  // Multiple assertions needed
const data = match(result.type)
  .with("A", () => {
    if (!result.fieldA) throw new Error("...");  // TypeScript doesn't see it
    return result.fieldA as string;  // More assertions!
  })
  .exhaustive();

// ✅ WORKING WITH TypeScript:
// 1. Validate once at boundary
const args = Schema.parse(rawInput);

// 2. Use simple narrowing
if (args.type === "A") {
  // TypeScript automatically knows fieldA exists
  return { data: args.fieldA };
}
```

## Layers of Safety

Build safety in layers:

### Layer 1: Runtime Validation (Zod)

Catches invalid data before it enters your code

### Layer 2: Type System (TypeScript)

Catches logic errors at compile time

### Layer 3: Linter (ESLint)

Catches patterns that bypass the first two layers

All three layers must work together. Don't bypass any layer:

- ❌ Type assertions bypass Layer 2
- ❌ `any` types bypass Layers 2 and 3
- ❌ Skip Zod validation bypasses Layer 1

## The Decision Tree

When you encounter unknown data:

```
Is the data from outside your code?
├─ YES → Validate with Zod first
│   └─ Schema defined?
│       ├─ YES → Use it
│       └─ NO → Create schema first
│
└─ NO → Trust TypeScript types
    └─ TypeScript complaining?
        ├─ Type error → Fix the actual issue
        └─ Union not narrowing → Use simple if/else
```

## Common Scenarios

### Scenario: API Response

```typescript
const response = await fetch(url);
const json: unknown = await response.json();  // Always unknown!
const validated = ResponseSchema.parse(json); // Validate
// Now use validated safely
```

### Scenario: Database Query

```typescript
// Known structure (Prisma types are good):
const user = await prisma.user.findUnique({ where: { id } });
// TypeScript knows the type

// Unknown structure (JSON field):
const config: unknown = JSON.parse(user.configJson);
const validated = ConfigSchema.parse(config);  // Validate!
```

### Scenario: Error Handling

```typescript
try {
  await operation();
} catch (error) {
  // error is unknown - validate to use
  const ErrorSchema = z.object({ message: z.string() });
  const result = ErrorSchema.safeParse(error);
  const message = result.success ? result.data.message : String(error);
}
```

### Scenario: Complex Union

```typescript
// Define union with Zod:
const InputSchema = z.union([
  z.object({ type: z.literal("A"), fieldA: z.string() }),
  z.object({ type: z.literal("B"), fieldB: z.number() }),
]);

const input = InputSchema.parse(rawInput);

// TypeScript narrows automatically:
if (input.type === "A") {
  console.log(input.fieldA);  // Works!
} else {
  console.log(input.fieldB);  // Works!
}
```

## Avoid These Anti-Patterns

### ❌ The Premature Cast

```typescript
const data = unknownData as MyType;  // Hope it's right!
```

**Instead**: Validate first, then use

### ❌ The Any Escape Hatch

```typescript
const data: any = getData();  // Disable all checking
```

**Instead**: Define proper types or use unknown + Zod

### ❌ The Type Guard Override

```typescript
function isMyType(value: unknown): value is MyType {
  return true;  // Trust me bro
}
```

**Instead**: Use Zod schemas for runtime checks

### ❌ The Multiple Assertion Chain

```typescript
const x = (data as unknown) as Type1;
const y = (x as unknown) as Type2;
```

**Instead**: Validate with Zod at the source

### ❌ The Non-Null Assertion

```typescript
const value = maybeValue!;  // It's definitely there! (maybe)
```

**Instead**: Use optional chaining or Zod

## Success Metrics

Your code is type-safe when:

✅ No `any` types (except in third-party library typings)
✅ No type assertions except `as const` and `as unknown as Type`
✅ All external data validated with Zod
✅ ESLint passes with no warnings
✅ TypeScript compiles with no errors
✅ No non-null assertions (`!`)
✅ Error handling uses Zod validation

## The Payoff

When you follow this strategy:

1. **Fewer bugs**: Invalid data caught at boundaries
2. **Better DX**: TypeScript autocomplete works correctly
3. **Easier refactoring**: Type errors show what needs updating
4. **Self-documenting**: Zod schemas document expected structure
5. **Faster iteration**: Get it right the first time, not after 5 linter passes

## Remember

> "If TypeScript is fighting you, you're probably fighting type safety. Stop fighting and start validating."

The effort to validate properly at boundaries is ALWAYS less than debugging production issues from invalid data.
