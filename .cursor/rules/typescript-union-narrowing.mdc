---
description: TypeScript union type narrowing strategies
---

# TypeScript Union Type Narrowing

## Use Simple if/else for Complex Unions

When TypeScript struggles to narrow complex union types (especially from Zod schemas), use simple `if/else` chains instead of pattern matching libraries.

### ❌ AVOID (when TypeScript can't narrow)

```typescript
import { match } from "ts-pattern";

const criteria = match(args.criteriaType)
  .with("TYPE_A", () => {
    if (!args.fieldA) throw new Error("..."); // TypeScript doesn't know fieldA exists
    return { type: "TYPE_A", fieldA: args.fieldA };
  })
  .exhaustive();
```

### ✅ PREFER

```typescript
let criteria: UnionType;

if (args.criteriaType === "TYPE_A") {
  // TypeScript automatically narrows args to include fieldA
  criteria = { type: "TYPE_A", fieldA: args.fieldA };
} else if (args.criteriaType === "TYPE_B") {
  criteria = { type: "TYPE_B", fieldB: args.fieldB };
} else {
  // Last branch - no exhaustive check needed for last case
  criteria = { type: "TYPE_C", fieldC: args.fieldC };
}
```

## When Union Narrowing Works Well

TypeScript's natural narrowing works best with:

- **Zod union schemas**: `z.union([SchemaA.and(FieldsA), SchemaB.and(FieldsB)])`
- **Discriminated unions**: Checked with `===` equality
- **Simple if/else chains**: TypeScript narrows automatically in each branch

## When to Avoid Pattern Matching

Avoid `ts-pattern` or complex matching when:

1. Zod schema unions have complex intersections
2. TypeScript shows "Property does not exist" errors despite Zod validation
3. You need many type assertions to make it work

## Type Safety Guarantee

The pattern works because:

1. **Zod validates at runtime**: Ensures the data structure is correct
2. **TypeScript narrows at compile time**: Knows which fields exist in each branch
3. **No type assertions needed**: TypeScript infers everything naturally

## Exhaustiveness: Avoid Plain `else` Blocks

**Plain `else` blocks can silently handle new cases when discriminated unions are extended.**

### ❌ DANGEROUS (plain `else`)

```typescript
type Status = "pending" | "success" | "error";

function handleStatus(status: Status) {
  if (status === "pending") {
    return "Waiting...";
  } else if (status === "success") {
    return "Done!";
  } else {
    // If we add "cancelled" to Status, this silently handles it!
    return "Failed!";
  }
}
```

### ✅ SAFE (exhaustive check)

```typescript
type Status = "pending" | "success" | "error";

function handleStatus(status: Status): string {
  if (status === "pending") {
    return "Waiting...";
  } else if (status === "success") {
    return "Done!";
  } else if (status === "error") {
    return "Failed!";
  }
  
  // Exhaustive check - TypeScript will error if we add a new Status
  const _exhaustive: never = status;
  throw new Error(`Unhandled status: ${String(_exhaustive)}`);
}
```

### ✅ ALSO SAFE (ts-pattern with exhaustive)

```typescript
import { match } from "ts-pattern";

function handleStatus(status: Status): string {
  return match(status)
    .with("pending", () => "Waiting...")
    .with("success", () => "Done!")
    .with("error", () => "Failed!")
    .exhaustive();  // TypeScript errors if we add a new Status
}
```

### When `else` is Acceptable

Plain `else` is acceptable when:

1. **Binary choice**: Only two possible values (e.g., `true`/`false`)
2. **Range check**: Numeric/string ranges where new values won't be added
3. **Default behavior**: When you genuinely want to handle "all other cases"

```typescript
// ✅ Acceptable - binary choice
if (isEnabled) {
  enable();
} else {
  disable();
}

// ✅ Acceptable - range with default
if (count === 0) {
  return "none";
} else if (count === 1) {
  return "one";
} else {
  return `${count} items`;  // Genuine default for all other numbers
}
```

### Key Rule

**If new values could be added to the discriminated union in the future, use `else if` with an exhaustive check or `ts-pattern` instead of plain `else`.**

## Example: Complex Union from Zod

```typescript
// Zod schema with 12 union variants
const Schema = z.union([
  CommonFields.and(DateTypeA).and(CriteriaTypeA),
  CommonFields.and(DateTypeA).and(CriteriaTypeB),
  // ... 10 more variants
]);

const args = Schema.parse(rawInput); // Validated!

// TypeScript now knows the exact shape based on discriminators
let result: ResultType;

if (args.dateType === "FIXED") {
  // TypeScript knows: startDate and endDate exist
  result = { dates: { start: args.startDate, end: args.endDate } };
} else {
  // TypeScript knows: seasonId exists
  result = { dates: { seasonId: args.seasonId } };
}

if (args.criteriaType === "MOST_GAMES") {
  // TypeScript knows: queue exists
  result.criteria = { type: "MOST_GAMES", queue: args.queue };
} else if (args.criteriaType === "WINS_CHAMPION") {
  // TypeScript knows: championId exists
  result.criteria = { type: "WINS_CHAMPION", championId: args.championId };
}
```

## Key Principle

**Let TypeScript's built-in narrowing do the work.** Don't fight the compiler with complex abstractions when simple code works better.
