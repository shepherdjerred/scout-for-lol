---
import { Font } from "astro:assets";
import { getExampleMatch } from "../example";
import { Report } from "@scout-for-lol/report/src/html/report.tsx";
---

<Font cssVariable="--font-beaufort-for-lol" preload />
<Font cssVariable="--font-spiegel" preload />

<div
  style={{
    zoom: 0.085,
  }}
>
  <Report match={getExampleMatch()} />
</div>

<div
  style={{
    zoom: 0.2,
  }}
>
  <Report match={getExampleMatch()} />
</div>

<script>
  function cleanFontFamilyNames() {
    // Function to clean font family name by removing random suffixes
    function cleanFontName(fontFamily: string | null): string {
      if (!fontFamily) return "";
      // Remove hash-like suffixes (e.g., "-352db090d8d25929")
      return fontFamily.replace(/-[a-f0-9]{16,}/g, "");
    }

    // Process all stylesheets
    Array.from(document.styleSheets).forEach((styleSheet) => {
      try {
        // Process all CSS rules
        const rules = styleSheet.cssRules;
        if (!rules) return;

        Array.from(rules).forEach((rule) => {
          if (rule instanceof CSSStyleRule) {
            // Handle :root CSS variables
            if (rule.selectorText === ":root") {
              Array.from(rule.style).forEach((property: string) => {
                if (property.startsWith("--font-")) {
                  const currentValue = rule.style.getPropertyValue(property);
                  const cleanedValue = cleanFontName(currentValue);
                  if (currentValue !== cleanedValue) {
                    rule.style.setProperty(property, cleanedValue);
                    console.log(`Updated CSS variable ${property}: ${currentValue} → ${cleanedValue}`);
                  }
                }
              });
            }
          } else if (rule instanceof CSSFontFaceRule) {
            // Handle @font-face rules
            const currentFontFamily = rule.style.fontFamily;
            if (currentFontFamily) {
              const cleanedFontFamily = cleanFontName(currentFontFamily);
              if (currentFontFamily !== cleanedFontFamily) {
                rule.style.fontFamily = cleanedFontFamily;
                console.log(`Updated @font-face: ${currentFontFamily} → ${cleanedFontFamily}`);
              }
            }
          }
        });
      } catch (e) {
        // Skip stylesheets that can't be accessed (CORS issues, etc.)
        console.warn("Could not access stylesheet:", e);
      }
    });

    // Also update any inline styles that might reference the font
    document.querySelectorAll('*[style*="font-family"]').forEach((element) => {
      const style = element.getAttribute("style");
      const cleanedStyle = cleanFontName(style);
      if (style !== cleanedStyle) {
        element.setAttribute("style", cleanedStyle);
        console.log("Updated inline style on element:", element);
      }
    });

    console.log("Font family cleanup completed");
  }

  // Run the cleanup when the page loads
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", cleanFontFamilyNames);
  } else {
    cleanFontFamilyNames();
  }

  // Also run after a short delay to catch dynamically loaded fonts
  setTimeout(cleanFontFamilyNames, 100);
</script>
