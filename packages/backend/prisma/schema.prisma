generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma/client"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model Subscription {
  id        Int    @id @default(autoincrement())
  playerId  Int
  channelId String
  player    Player @relation(fields: [playerId], references: [id])

  // metadata
  serverId         String
  creatorDiscordId String
  createdTime      DateTime
  updatedTime      DateTime

  @@unique([serverId, playerId, channelId])
}

model Player {
  id                       Int                       @id @default(autoincrement())
  alias                    String
  discordId                String?
  accounts                 Account[]
  subscriptions            Subscription[]
  competitionParticipants  CompetitionParticipant[]
  competitionSnapshots     CompetitionSnapshot[]

  // metadata
  serverId         String
  creatorDiscordId String
  createdTime      DateTime
  updatedTime      DateTime

  @@unique([serverId, alias])
}

model Account {
  id       Int    @id @default(autoincrement())
  alias    String
  // TODO: store riot ID for the sake of easier understanding
  puuid    String
  region   String
  playerId Int
  player   Player @relation(fields: [playerId], references: [id])

  // Activity tracking for dynamic polling
  lastSeenInGame DateTime? // When we last detected this account in an active game (deprecated - kept for future use)
  lastProcessedMatchId String? // Track last match we've processed to avoid duplicates

  // metadata
  serverId         String
  creatorDiscordId String
  createdTime      DateTime
  updatedTime      DateTime

  @@unique([serverId, puuid])
}

model Competition {
  id               Int                       @id @default(autoincrement())
  serverId         String
  ownerId          String // Discord user ID
  title            String
  description      String
  channelId        String
  isCancelled      Boolean                   @default(false)
  visibility       String // OPEN, INVITE_ONLY, SERVER_WIDE
  criteriaType     String // Enum stored as string
  criteriaConfig   String // JSON stored as string
  maxParticipants  Int                       @default(50)

  // Time configuration (XOR: either fixed dates OR season)
  startDate        DateTime?
  endDate          DateTime?
  seasonId         String?

  // Relations
  participants     CompetitionParticipant[]
  snapshots        CompetitionSnapshot[]

  // Metadata
  creatorDiscordId String
  createdTime      DateTime
  updatedTime      DateTime

  // Note: We do NOT have a unique constraint on [serverId, ownerId]
  // This allows users to create multiple competitions over time
  // The "one active competition per owner" rule is enforced in application logic
  @@index([serverId, isCancelled])
  @@index([serverId, ownerId, isCancelled])
}

model CompetitionParticipant {
  id            Int         @id @default(autoincrement())
  competitionId Int
  playerId      Int
  status        String // INVITED, JOINED, LEFT
  invitedBy     String? // Discord user ID (nullable)
  invitedAt     DateTime? // When invited (nullable - null if joined directly)
  joinedAt      DateTime? // When joined (nullable - null if only invited)
  leftAt        DateTime? // When left (nullable - null if still participating)

  // Relations
  competition   Competition @relation(fields: [competitionId], references: [id], onDelete: Cascade)
  player        Player      @relation(fields: [playerId], references: [id])

  @@unique([competitionId, playerId])
  @@index([competitionId, status])
}

model CompetitionSnapshot {
  id           Int         @id @default(autoincrement())
  competitionId Int
  playerId     Int
  snapshotType String // START, END
  snapshotData String // JSON stored as string
  snapshotTime DateTime

  // Relations
  competition  Competition @relation(fields: [competitionId], references: [id], onDelete: Cascade)
  player       Player      @relation(fields: [playerId], references: [id])

  @@unique([competitionId, playerId, snapshotType])
}

model ServerPermission {
  id            Int      @id @default(autoincrement())
  serverId      String
  discordUserId String
  permission    String // CREATE_COMPETITION (can add more later)
  grantedBy     String // Discord user ID
  grantedAt     DateTime

  @@unique([serverId, discordUserId, permission])
}

model GuildPermissionError {
  id                    Int      @id @default(autoincrement())
  serverId              String
  channelId             String
  errorType             String // Type of permission error
  errorReason           String? // Detailed reason
  firstOccurrence       DateTime // When this error first occurred
  lastOccurrence        DateTime // Most recent occurrence
  consecutiveErrorCount Int      @default(1) // Number of consecutive errors
  lastSuccessfulSend    DateTime? // Last time a message was successfully sent to this server
  ownerNotified         Boolean  @default(false) // Whether owner was notified about abandonment
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@unique([serverId, channelId])
  @@index([serverId, consecutiveErrorCount])
  @@index([lastOccurrence])
}
